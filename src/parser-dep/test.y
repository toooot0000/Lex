%skeleton "lalr1.cc"
%require "3.2"
%language "c++"
%define api.namespace {yy}
%define api.parser.class {parser}
%define api.value.type variant
%define api.token.constructor
%define parse.error verbose
%header
%output "parser.cpp"
%locations
%define api.location.file "location.hpp"

%code requires{
  namespace yy 
  {
    class Lexer;  // Generated by reflex with namespace=yy lexer=Lexer lex=yylex
  }
}

%parse-param { yy::Lexer& lexer }  // Construct parser object with lexer
%code{
  #include "lex.yy.h"  // header file generated with reflex --header-file
  #undef yylex
  #define yylex lexer.lex  // Within bison's parse() we should invoke lexer.yylex(), not the global yylex()
}

%define api.token.prefix {TOK_}

%token
  ASSIGN  "="
  MINUS   "-"
  PLUS    "+"
  STAR    "*"
  SLASH   "/"
  LPAREN  "("
  RPAREN  ")"
  COLON   ":"
  DQUOTE  "\""
  QUATE   "\'"
;

%token
  BEGIN "Begin"
  END "End"
  IF "If"
  THEN "Then"
  ELSE "Else"
  FOR "For"
  IN "In"
  FROM "FROM"
;

%token <int> IDENTIFIER "identifier"  // This defines TOK_IDENTIFIER
%token <int> INTEGER "integer"                  // This defines TOK_NUMBER
%token <std::string> STRING "string"
%token EOF 0 "end of file"                    // This defines TOK_EOF with value 0

%start stmt
@ntmn <int> assign;
@ntmn <int> expr;

%%

stmt :
  %empty        ;
  ''
  | expr stmt   ;
  ;


assign :
  IDENTIFIER '=' INTEGER    { 
    $1 = $3; 
    $$ = $3;
    std::cout << "Assignment: " << $1 << " = " << "$3" << std::endl;
  }
  ;

expr :
  INTEGER             { $$ = $1; }
  | IDENTIFIER        { $$ = $1; }
  | expr '+' expr     
  | expr '-' expr
  | expr '*' expt
  | expr '/' expt
  ;




%%

void yy::parser::error(const location& loc, const std::string& msg){
  std::cerr << loc << ": " << msg << std::endl;
  if (lexer.size() == 0)      // if token is unknown (no match)
    lexer.matcher().winput(); // skip character
}